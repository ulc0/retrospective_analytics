R: Survival analysis with BART  
[surv.bart {BART}](https://search.r-project.org/CRAN/refmans/BART/html/surv.bart.html)

R Documentation

Survival analysis with BART
---------------------------

### Description

Here we have implemented a simple and direct approach to utilize BART in survival analysis that is very flexible, and is akin to discrete-time survival analysis. Following the capabilities of BART, we allow for maximum flexibility in modeling the dependence of survival times on covariates. In particular, we do not impose proportional hazards.

To elaborate, consider data in the usual form: `(t_i, \delta_i, {x}_i)` where `t_i` is the event time, `\delta_i` is an indicator distinguishing events (`\delta=1`) from right-censoring (`\delta=0`), `{x}_i` is a vector of covariates, and `i=1, ..., N` indexes subjects.

We denote the `K` distinct event/censoring times by `0<t_{(1)}<...<t_{(K)}<\infty` thus taking `t_{(j)}` to be the `j^{th}` order statistic among distinct observation times and, for convenience, `t_{(0)}=0`. Now consider event indicators `y_{ij}` for each subject `i` at each distinct time `t_{(j)}` up to and including the subject's observation time `t_i=t_{(n_i)}` with `n_i=\sum_j I[t_{(j)}\leq t_i]`. This means `y_{ij}=0` if `j<n_i` and `y_{in_i}=\delta_i`.

We then denote by `p_{ij}` the probability of an event at time `t_{(j)}` conditional on no previous event. We now write the model for `y_{ij}` as a nonparametric probit regression of `y_{ij}` on the time `t_{(j)}` and the covariates `{x}_i`, and then utilize BART for binary responses. Specifically, `y_{ij}\ =\ \delta_i I[t_i=t_{(j)}],\ j=1, ..., n_i` ; we have `p_{ij} = F(\mu_{ij}),\ \mu_{ij} = \mu_0+f(t_{(j)}, {x}_i)` where `F` denotes the standard normal cdf (probit link). As in the binary response case, `f` is the sum of many tree models.

### Usage

    
    surv.bart( x.train=matrix(0,0,0),
               y.train=NULL, times=NULL, delta=NULL,
               x.test=matrix(0,0,0),
               K=NULL, events=NULL, ztimes=NULL, zdelta=NULL,
               sparse=FALSE, theta=0, omega=1,
               a=0.5, b=1, augment=FALSE, rho=NULL,
               xinfo=matrix(0,0,0), usequants=FALSE,
               
               rm.const=TRUE, type='pbart',
               ntype=as.integer(
                   factor(type, levels=c('wbart', 'pbart', 'lbart'))),
               k=2, power=2, base=.95,
               offset=NULL, tau.num=c(NA, 3, 6)[ntype], 
               ntree=50, numcut=100, ndpost=1000, nskip=250,
               keepevery = 10L,
               
               
               
               
               printevery=100L, 
               
               id=NULL,    ## surv.bart only
               seed=99,    ## mc.surv.bart only
               mc.cores=2, ## mc.surv.bart only
               nice=19L    ## mc.surv.bart only
             )
    
    mc.surv.bart( x.train=matrix(0,0,0),
                  y.train=NULL, times=NULL, delta=NULL, 
                  x.test=matrix(0,0,0), 
                  K=NULL, events=NULL, ztimes=NULL, zdelta=NULL,
                  sparse=FALSE, theta=0, omega=1,
                  a=0.5, b=1, augment=FALSE, rho=NULL,
                  xinfo=matrix(0,0,0), usequants=FALSE,
                  
                  rm.const=TRUE, type='pbart',
                  ntype=as.integer(
                      factor(type, levels=c('wbart', 'pbart', 'lbart'))),
                  k=2, power=2, base=.95,
                  offset=NULL, tau.num=c(NA, 3, 6)[ntype], 
                  ntree=50, numcut=100, ndpost=1000, nskip=250,
                  keepevery = 10L,
                  
                  
                  
                  
                  printevery=100L, 
                  
                  id=NULL,    ## surv.bart only
                  seed=99,    ## mc.surv.bart only
                  mc.cores=2, ## mc.surv.bart only
                  nice=19L    ## mc.surv.bart only
                )
    

### Arguments

`x.train`

Explanatory variables for training (in sample) data.  
Must be a matrix with (as usual) rows corresponding to observations and columns to variables.  
`surv.bart` will generate draws of `f(t, x)` for each `x` which is a row of x.train (note that the definition of `x.train` is dependent on whether `y.train` has been specified; see below).

`y.train`

Binary response dependent variable for training (in sample) data.  
If `y.train` is `NULL`, then `y.train` (`x.train` and `x.test`, if specified) are generated by a call to `surv.pre.bart` (which require that `times` and `delta` be provided: see below); otherwise, `y.train` (`x.train` and `x.test`, if specified) are utilized as given assuming that the data construction has already been performed.

`times`

The time of event or right-censoring.  
If `y.train` is `NULL`, then `times` (and `delta`) must be provided.

`delta`

The event indicator: 1 is an event while 0 is censored.  
If `y.train` is `NULL`, then `delta` (and `times`) must be provided.

`x.test`

Explanatory variables for test (out of sample) data.  
Must be a matrix and have the same structure as x.train.  
`surv.bart` will generate draws of `f(t, x)` for each `x` which is a row of x.test.

`K`

If provided, then coarsen `times` per the quantiles `1/K, 2/K, ..., K/K`.

`events`

If provided, then use for the grid of time points.

`ztimes`

If provided, then these columns of `x.train` (and `x.test` if any) are the times for time-dependent covariates. They will be transformed into time-dependent covariate sojourn times.

`zdelta`

If provided, then these columns of `x.train` (and `x.test` if any) are the delta for time-dependent covariates. They will be transformed into time-dependent covariate binary events.

`sparse`

Whether to perform variable selection based on a sparse Dirichlet prior rather than simply uniform; see Linero 2016.

`theta`

Set `theta` parameter; zero means random.

`omega`

Set `omega` parameter; zero means random.

`a`

Sparse parameter for `Beta(a, b)` prior: `0.5<=a<=1` where lower values inducing more sparsity.

`b`

Sparse parameter for `Beta(a, b)` prior; typically, `b=1`.

`rho`

Sparse parameter: typically `rho=p` where `p` is the number of covariates under consideration.

`augment`

Whether data augmentation is to be performed in sparse variable selection.

`xinfo`

You can provide the cutpoints to BART or let BART choose them for you. To provide them, use the `xinfo` argument to specify a list (matrix) where the items (rows) are the covariates and the contents of the items (columns) are the cutpoints.

`usequants`

If `usequants=FALSE`, then the cutpoints in `xinfo` are generated uniformly; otherwise, if `TRUE`, uniform quantiles are used for the cutpoints.

`rm.const`

Whether or not to remove constant variables.

`type`

Whether to employ Albert-Chib, `'pbart'`, or Holmes-Held, `'lbart'`.

`ntype`

The integer equivalent of `type` where `'wbart'` is 1, `'pbart'` is 2 and `'lbart'` is 3.

`k`

k is the number of prior standard deviations `f(t, x)` is away from +/-3. The bigger k is, the more conservative the fitting will be.

`power`

Power parameter for tree prior.

`base`

Base parameter for tree prior.

`offset`

With binary BART, the centering is `P(Y=1 | x) = F(f(x) + offset)` where `offset` defaults to `F^{-1}(mean(y.train))`. You can use the `offset` parameter to over-ride these defaults.

`tau.num`

The numerator in the `tau` definition, i.e., `tau=tau.num/(k*sqrt(ntree))`.

`ntree`

The number of trees in the sum.

`ndpost`

The number of posterior draws returned.

`nskip`

Number of MCMC iterations to be treated as burn in.

`printevery`

As the MCMC runs, a message is printed every printevery draws.

`keepevery`

Every keepevery draw is kept to be returned to the user.  
A “draw” will consist of values `f^*(t, x)` at `x` = rows from the train(optionally) and test data, where `f^*` denotes the current draw of `f`.

`numcut`

The number of possible values of c (see usequants). If a single number if given, this is used for all variables. Otherwise a vector with length equal to ncol(x.train) is required, where the `i^{th}` element gives the number of c used for the `i^{th}` variable in x.train. If usequants is false, numcut equally spaced cutoffs are used covering the range of values in the corresponding column of x.train. If usequants is true, then min(numcut, the number of unique values in the corresponding columns of x.train - 1) c values are used.

`id`

`surv.bart` only: unique identifier added to returned list.

`seed`

`mc.surv.bart` only: seed required for reproducible MCMC.

`mc.cores`

`mc.surv.bart` only: number of cores to employ in parallel.

`nice`

`mc.surv.bart` only: set the job niceness. The default niceness is 19: niceness goes from 0 (highest) to 19 (lowest).

### Value

`surv.bart` returns an object of type `survbart` which is essentially a list. Besides the items listed below, the list has a `binaryOffset` component giving the value used, a `times` component giving the unique times, `K` which is the number of unique times, `tx.train` and `tx.test`, if any.

`yhat.train`

A matrix with ndpost rows and nrow(x.train) columns. Each row corresponds to a draw `f^*` from the posterior of `f` and each column corresponds to a row of x.train. The `(i,j)` value is `f^*(t, x)` for the `i^{th}` kept draw of `f` and the `j^{th}` row of x.train.  
Burn-in is dropped.

`yhat.test`

Same as yhat.train but now the x's are the rows of the test data.

`surv.test`

The survival function, `S(t|x)`, where x's are the rows of the test data.

`yhat.train.mean`

train data fits = mean of yhat.train columns.

`yhat.test.mean`

test data fits = mean of yhat.test columns.

`surv.test.mean`

mean of surv.test columns.

`varcount`

a matrix with ndpost rows and nrow(x.train) columns. Each row is for a draw. For each variable (corresponding to the columns), the total count of the number of times that variable is used in a tree decision rule (over all trees) is given.

Note that yhat.train and yhat.test are `f(t, x)` + `binaryOffset`. If you want draws of the probability `P(Y=1 | t, x)` you need to apply the normal cdf (`pnorm`) to these values.

### See Also

`[surv.pre.bart](../../BART/help/surv.pre.bart.html)`

### Examples

    
    ## load survival package for the advanced lung cancer example
    data(lung)
    
    N <- length(lung$status)
    
    table(lung$ph.karno, lung$pat.karno)
    
    ## if physician's KPS unavailable, then use the patient's
    h <- which(is.na(lung$ph.karno))
    lung$ph.karno[h] <- lung$pat.karno[h]
    
    times <- lung$time
    delta <- lung$status-1 ##lung$status: 1=censored, 2=dead
    ##delta: 0=censored, 1=dead
    
    ## this study reports time in days rather than weeks or months
    ## coarsening from days to weeks or months will reduce the computational burden
    ##times <- ceiling(times/30)
    times <- ceiling(times/7)  ## weeks
    
    table(times)
    table(delta)
    
    ## matrix of observed covariates
    x.train <- cbind(lung$sex, lung$age, lung$ph.karno)
    
    ## lung$sex:        Male=1 Female=2
    ## lung$age:        Age in years
    ## lung$ph.karno:   Karnofsky performance score (dead=0:normal=100:by=10)
    ##                  rated by physician
    
    dimnames(x.train)[[2]] <- c('M(1):F(2)', 'age(39:82)', 'ph.karno(50:100:10)')
    
    table(x.train[ , 1])
    summary(x.train[ , 2])
    table(x.train[ , 3])
    
    ##test BART with token run to ensure installation works
    set.seed(99)
    post <- surv.bart(x.train=x.train, times=times, delta=delta,
                      nskip=1, ndpost=1, keepevery=1)
    
    ## Not run: 
    ## run one long MCMC chain in one process
    ## set.seed(99)
    ## post <- surv.bart(x.train=x.train, times=times, delta=delta, x.test=x.test)
    
    ## in the interest of time, consider speeding it up by parallel processing
    ## run "mc.cores" number of shorter MCMC chains in parallel processes
    post <- mc.surv.bart(x.train=x.train, times=times, delta=delta,
                         mc.cores=8, seed=99)
    
    pre <- surv.pre.bart(times=times, delta=delta, x.train=x.train,
                         x.test=x.train)
    
    K <- pre$K
    M <- nrow(post$yhat.train)
    
    pre$tx.test <- rbind(pre$tx.test, pre$tx.test)
    pre$tx.test[ , 2] <- c(rep(1, N*K), rep(2, N*K))
    ## sex pushed to col 2, since time is always in col 1
    
    pred <- predict(post, newdata=pre$tx.test, mc.cores=8)
    
    pd <- matrix(nrow=M, ncol=2*K)
    
    for(j in 1:K) {
        h <- seq(j, N*K, by=K)
        pd[ , j] <- apply(pred$surv.test[ , h], 1, mean)
        pd[ , j+K] <- apply(pred$surv.test[ , h+N*K], 1, mean)
    }
    
    pd.mu  <- apply(pd, 2, mean)
    pd.025 <- apply(pd, 2, quantile, probs=0.025)
    pd.975 <- apply(pd, 2, quantile, probs=0.975)
    
    males <- 1:K
    females <- males+K
    
    plot(c(0, pre$times), c(1, pd.mu[males]), type='s', col='blue',
         ylim=0:1, ylab='S(t, x)', xlab='t (weeks)',
         main=paste('Advanced Lung Cancer ex. (BART::lung)',
                    "Friedman's partial dependence function",
                    'Male (blue) vs. Female (red)', sep='\n'))
    lines(c(0, pre$times), c(1, pd.025[males]), col='blue', type='s', lty=2)
    lines(c(0, pre$times), c(1, pd.975[males]), col='blue', type='s', lty=2)
    lines(c(0, pre$times), c(1, pd.mu[females]), col='red', type='s')
    lines(c(0, pre$times), c(1, pd.025[females]), col='red', type='s', lty=2)
    lines(c(0, pre$times), c(1, pd.975[females]), col='red', type='s', lty=2)
    
    
    
    ## End(Not run)
    

* * *

\[Package _BART_ version 2.9.4 [Index](00Index.html)\]